package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
)

type Product struct {
	ID              int
	Name            string
	Description     string
	Category        string
	StorageCondition string
	batches         []Batch
}

type Batch struct {
	ProductID    int
	BatchID      int
	ExpirationDate string
	Quantity     int
}

var products []Product
var batches []Batch

func main() {
	for {
		fmt.Println("1. Add product")
		fmt.Println("2. Add batch")
		fmt.Println("3. Monitor inventory")
		fmt.Println("4. Export to CSV")
		fmt.Println("5. Exit")

		var choice int
		fmt.Scan(&choice)

		switch choice {
		case 1:
			addProduct()
	case 2:
			addBatch()
		case 3:
			monitorInventory()
		case 4:
			exportToCSV()
		case 5:
			os.Exit(0)
		default:
			fmt.Println("Invalid choice")
		}
	}
}

func addProduct() {
	var id int
	var name, description, category, storageCondition string

	fmt.Print("Enter product name: ")
	fmt.Scan(&name)

	fmt.Print("Enter product description: ")
	fmt.Scan(&description)

	fmt.Print("Enter product category: ")
	fmt.Scan(&category)

	fmt.Print("Enter product storage condition: ")
	fmt.Scan(&storageCondition)

	id = len(products) + 1

	newProduct := Product{
		ID:              id,
		Name:            name,
		Description:     description,
		Category:        category,
		StorageCondition: storageCondition,
	}

	products = append(products, newProduct)
	fmt.Println("Product added successfully")
}

func addBatch() {
	var productID, batchID int
	var expirationDate string
	var quantity int

	fmt.Print("Enter product ID: ")
	fmt.Scan(&productID)

	fmt.Print("Enter batch ID: ")
	fmt.Scan(&batchID)

	fmt.Print("Enter expiration date (YYYY-MM-DD): ")
	fmt.Scan(&expirationDate)

	fmt.Print("Enter quantity: ")
	fmt.Scan(&quantity)

	newBatch := Batch{
		ProductID:    productID,
		BatchID:      batchID,
		ExpirationDate: expirationDate,
		Quantity:     quantity,
	}

	for i, product := range products {
		if product.ID == productID {
			products[i].batches = append(products[i].batches, newBatch)
			fmt.Println("Batch added successfully")
			return
		}
	}

	fmt.Println("Product not found")
}

func monitorInventory() {
	for {
		fmt.Println("Enter product ID to monitor inventory: ")
		var productID int
		fmt.Scan(&productID)

		for _, product := range products {
			if product.ID == productID {
				fmt.Printf("Product: %s\n", product.Name)
				fmt.Println("Batches:")
				for _, batch := range product.batches {
					fmt.Printf("Batch ID: %d, Expiration Date: %s, Quantity: %d\n", batch.BatchID, batch.ExpirationDate, batch.Quantity)
				}
				fmt.Println("Press enter to continue")
				fmt.Scanln()
				break
			}
		}

		fmt.Println("Product not found")
	}
}

func exportToCSV() {
	file, err := os.Create("inventory.csv")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	header := []string{"ID", "Name", "Description", "Category", "Storage Condition", "Batch ID", "Expiration Date", "Quantity"}
	writer.Write(header)

	for _, product := range products {
		for _, batch := range product.batches {
			row := []string{
				fmt.Sprint(product.ID),
				product.Name,
				product.Description,
				product.Category,
				product.StorageCondition,
				fmt.Sprint(batch.BatchID),
				batch.ExpirationDate,
				fmt.Sprint(batch.Quantity),
			}
			writer.Write(row)
		}
	}

	fmt.Println("Inventory exported to CSV")
}